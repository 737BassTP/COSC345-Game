        -:    0:Source:src/functions.c
        -:    0:Programs:17
        -:    1://Definitions.
        -:    2:#include "everything.h"
        -:    3:
        -:    4:
        -:    5:
        -:    6:
        -:    7:extern const int c_black    = 0x000000;
        -:    8:extern const int c_dkgray   = 0x404040;
        -:    9:extern const int c_gray     = 0x808080;
        -:   10:extern const int c_ltgray   = 0xC0C0C0;
        -:   11:extern const int c_white    = 0xFFFFFF;
        -:   12:extern const int c_red      = 0x0000FF; 
        -:   13:extern const int c_orange   = 0x0080FF;
        -:   14:extern const int c_yellow   = 0x00FFFF;
        -:   15:extern const int c_lime     = 0x00FF80;
        -:   16:extern const int c_green    = 0x00FF00;
        -:   17:extern const int c_slime    = 0x80FF00;
        -:   18:extern const int c_aqua     = 0xFFFF00;//turquoise
        -:   19:extern const int c_sky      = 0xFF8000;
        -:   20:extern const int c_blue     = 0xFF0000;
        -:   21:extern const int c_purple   = 0xFF0080;
        -:   22:extern const int c_fuchsia  = 0xFF00FF;
        -:   23:extern const int c_rose     = 0x8000FF;
        -:   24://extern const int c_ = 0x;
        -:   25://extern const int c_ = 0x;
        -:   26:
        -:   27://Global variables.
        -:   28:extern int glob_draw_alpha = 255;
        -:   29:extern int glob_draw_color = c_white;
        -:   30:extern int glob_vk_right   = 0;
        -:   31:extern int glob_vk_left    = 0;
        -:   32:extern int glob_vk_up 	   = 0;
        -:   33:extern int glob_vk_down    = 0;
        -:   34:extern int glob_vk_space   = 0;
        -:   35:extern int glob_vk_enter   = 0;
        -:   36:extern int glob_vk_f2      = 0;
        -:   37:extern int glob_vk_0       = 0;
        -:   38:extern int glob_vk_1       = 0;
        -:   39:extern int glob_vk_2       = 0;
        -:   40:extern int glob_vk_3       = 0;
        -:   41:extern int glob_vk_4       = 0;
        -:   42:extern int glob_vk_5       = 0;
        -:   43:extern int glob_vk_6       = 0;
        -:   44:extern int glob_vk_7       = 0;
        -:   45:extern int glob_vk_8       = 0;
        -:   46:extern int glob_vk_9       = 0;
        -:   47://extern int glob_vk_;
        -:   48://extern int glob_vk_;
        -:   49:
        -:   50://Clear the surface by filling it with a colour.
    #####:   51:void clear_screen(SDL_Surface *surface)
        -:   52:{
    #####:   53:    if(SDL_FillRect(surface, NULL, 0xFF000040) < 0){
    #####:   54:        fprintf(stderr, "Unable to clear the surface. Error returned: %s\n", SDL_GetError());
    #####:   55:        SDL_Quit();
    #####:   56:        exit(EXIT_FAILURE);
        -:   57:    }
    #####:   58:}
------------------
clear_screen:
    #####:   51:void clear_screen(SDL_Surface *surface)
        -:   52:{
    #####:   53:    if(SDL_FillRect(surface, NULL, 0xFF000040) < 0){
    #####:   54:        fprintf(stderr, "Unable to clear the surface. Error returned: %s\n", SDL_GetError());
    #####:   55:        SDL_Quit();
    #####:   56:        exit(EXIT_FAILURE);
        -:   57:    }
    #####:   58:}
------------------
clear_screen:
    #####:   51:void clear_screen(SDL_Surface *surface)
        -:   52:{
    #####:   53:    if(SDL_FillRect(surface, NULL, 0xFF000040) < 0){
    #####:   54:        fprintf(stderr, "Unable to clear the surface. Error returned: %s\n", SDL_GetError());
    #####:   55:        SDL_Quit();
    #####:   56:        exit(EXIT_FAILURE);
        -:   57:    }
    #####:   58:}
------------------
     3678:   59:int make_color_rgb(int r,int g,int b)
        -:   60:{
     3678:   61:	return (r&0xFF)|((g&0xFF)<<8)|((b&0xFF)<<16);
        -:   62:}
------------------
make_color_rgb:
     1839:   59:int make_color_rgb(int r,int g,int b)
        -:   60:{
     1839:   61:	return (r&0xFF)|((g&0xFF)<<8)|((b&0xFF)<<16);
        -:   62:}
------------------
make_color_rgb:
     1839:   59:int make_color_rgb(int r,int g,int b)
        -:   60:{
     1839:   61:	return (r&0xFF)|((g&0xFF)<<8)|((b&0xFF)<<16);
        -:   62:}
------------------
  1937022:   63:double lerp(double from,double to,double percentage)
        -:   64:{
        -:   65:	//Lerp = Linear Interpolation.
  1937022:   66:	return from+(to-from)*percentage;
        -:   67:}
------------------
lerp:
   968511:   63:double lerp(double from,double to,double percentage)
        -:   64:{
        -:   65:	//Lerp = Linear Interpolation.
   968511:   66:	return from+(to-from)*percentage;
        -:   67:}
------------------
lerp:
   968511:   63:double lerp(double from,double to,double percentage)
        -:   64:{
        -:   65:	//Lerp = Linear Interpolation.
   968511:   66:	return from+(to-from)*percentage;
        -:   67:}
------------------
     3678:   68:int make_color_hsv(int h,int s,int v)
        -:   69:{
        -:   70:	//source: https://stackoverflow.com/questions/3018313/algorithm-to-convert-rgb-to-hsv-and-hsv-to-rgb-in-range-0-255-for-both/14733008#14733008
        -:   71:	byte region, remainder, p, q, t;
     3678:   72:    if (s == 0) {return make_color_rgb(v,v,v);}
     1664:   73:    region = h / 43;
     1664:   74:    remainder = (h - (region * 43)) * 6; 
     1664:   75:    p = (v * (255 - s)) >> 8;
     1664:   76:    q = (v * (255 - ((s * remainder) >> 8))) >> 8;
     1664:   77:    t = (v * (255 - ((s * (255 - remainder)) >> 8))) >> 8;
        -:   78:	byte rr,gg,bb;//if buggy, change to int.
     1664:   79:    switch (region)
        -:   80:    {
    #####:   81:        case 0:
    #####:   82:            rr = v; gg = t; bb = p;
    #####:   83:            break;
      288:   84:        case 1:
      288:   85:            rr = q; gg = v; bb = p;
      288:   86:            break;
      768:   87:        case 2:
      768:   88:            rr = p; gg = v; bb = t;
      768:   89:            break;
      608:   90:        case 3:
      608:   91:            rr = p; gg = q; bb = v;
      608:   92:            break;
    #####:   93:        case 4:
    #####:   94:            rr = t; gg = p; bb = v;
    #####:   95:            break;
    #####:   96:        default:
    #####:   97:            rr = v; gg = p; bb = q;
    #####:   98:            break;
        -:   99:    }
     1664:  100:    return make_color_rgb(rr,gg,bb);
        -:  101:}
------------------
make_color_hsv:
     1839:   68:int make_color_hsv(int h,int s,int v)
        -:   69:{
        -:   70:	//source: https://stackoverflow.com/questions/3018313/algorithm-to-convert-rgb-to-hsv-and-hsv-to-rgb-in-range-0-255-for-both/14733008#14733008
        -:   71:	byte region, remainder, p, q, t;
     1839:   72:    if (s == 0) {return make_color_rgb(v,v,v);}
      832:   73:    region = h / 43;
      832:   74:    remainder = (h - (region * 43)) * 6; 
      832:   75:    p = (v * (255 - s)) >> 8;
      832:   76:    q = (v * (255 - ((s * remainder) >> 8))) >> 8;
      832:   77:    t = (v * (255 - ((s * (255 - remainder)) >> 8))) >> 8;
        -:   78:	byte rr,gg,bb;//if buggy, change to int.
      832:   79:    switch (region)
        -:   80:    {
    #####:   81:        case 0:
    #####:   82:            rr = v; gg = t; bb = p;
    #####:   83:            break;
      144:   84:        case 1:
      144:   85:            rr = q; gg = v; bb = p;
      144:   86:            break;
      384:   87:        case 2:
      384:   88:            rr = p; gg = v; bb = t;
      384:   89:            break;
      304:   90:        case 3:
      304:   91:            rr = p; gg = q; bb = v;
      304:   92:            break;
    #####:   93:        case 4:
    #####:   94:            rr = t; gg = p; bb = v;
    #####:   95:            break;
    #####:   96:        default:
    #####:   97:            rr = v; gg = p; bb = q;
    #####:   98:            break;
        -:   99:    }
      832:  100:    return make_color_rgb(rr,gg,bb);
        -:  101:}
------------------
make_color_hsv:
     1839:   68:int make_color_hsv(int h,int s,int v)
        -:   69:{
        -:   70:	//source: https://stackoverflow.com/questions/3018313/algorithm-to-convert-rgb-to-hsv-and-hsv-to-rgb-in-range-0-255-for-both/14733008#14733008
        -:   71:	byte region, remainder, p, q, t;
     1839:   72:    if (s == 0) {return make_color_rgb(v,v,v);}
      832:   73:    region = h / 43;
      832:   74:    remainder = (h - (region * 43)) * 6; 
      832:   75:    p = (v * (255 - s)) >> 8;
      832:   76:    q = (v * (255 - ((s * remainder) >> 8))) >> 8;
      832:   77:    t = (v * (255 - ((s * (255 - remainder)) >> 8))) >> 8;
        -:   78:	byte rr,gg,bb;//if buggy, change to int.
      832:   79:    switch (region)
        -:   80:    {
    #####:   81:        case 0:
    #####:   82:            rr = v; gg = t; bb = p;
    #####:   83:            break;
      144:   84:        case 1:
      144:   85:            rr = q; gg = v; bb = p;
      144:   86:            break;
      384:   87:        case 2:
      384:   88:            rr = p; gg = v; bb = t;
      384:   89:            break;
      304:   90:        case 3:
      304:   91:            rr = p; gg = q; bb = v;
      304:   92:            break;
    #####:   93:        case 4:
    #####:   94:            rr = t; gg = p; bb = v;
    #####:   95:            break;
    #####:   96:        default:
    #####:   97:            rr = v; gg = p; bb = q;
    #####:   98:            break;
        -:   99:    }
      832:  100:    return make_color_rgb(rr,gg,bb);
        -:  101:}
------------------
  1159500:  102:int draw_get_alpha()
        -:  103:{
  1159500:  104:	return glob_draw_alpha;
        -:  105:}
------------------
draw_get_alpha:
   579750:  102:int draw_get_alpha()
        -:  103:{
   579750:  104:	return glob_draw_alpha;
        -:  105:}
------------------
draw_get_alpha:
   579750:  102:int draw_get_alpha()
        -:  103:{
   579750:  104:	return glob_draw_alpha;
        -:  105:}
------------------
   575046:  106:int draw_get_color()
        -:  107:{
   575046:  108:	return glob_draw_color;
        -:  109:}
------------------
draw_get_color:
   287523:  106:int draw_get_color()
        -:  107:{
   287523:  108:	return glob_draw_color;
        -:  109:}
------------------
draw_get_color:
   287523:  106:int draw_get_color()
        -:  107:{
   287523:  108:	return glob_draw_color;
        -:  109:}
------------------
  1159500:  110:void draw_set_color(SDL_Renderer* renderer,int bgr)
        -:  111:{
  1159500:  112:	glob_draw_color = bgr&0xFFFFFF;
  1159500:  113:	SDL_SetRenderDrawColor(renderer,bgr&0xFF,(bgr>>8)&0xFF,(bgr>>16)&0xFF,draw_get_alpha());
  1159500:  114:}
------------------
draw_set_color:
   579750:  110:void draw_set_color(SDL_Renderer* renderer,int bgr)
        -:  111:{
   579750:  112:	glob_draw_color = bgr&0xFFFFFF;
   579750:  113:	SDL_SetRenderDrawColor(renderer,bgr&0xFF,(bgr>>8)&0xFF,(bgr>>16)&0xFF,draw_get_alpha());
   579750:  114:}
------------------
draw_set_color:
   579750:  110:void draw_set_color(SDL_Renderer* renderer,int bgr)
        -:  111:{
   579750:  112:	glob_draw_color = bgr&0xFFFFFF;
   579750:  113:	SDL_SetRenderDrawColor(renderer,bgr&0xFF,(bgr>>8)&0xFF,(bgr>>16)&0xFF,draw_get_alpha());
   579750:  114:}
------------------
    #####:  115:void draw_set_alpha(SDL_Renderer* renderer,int alpha)
        -:  116:{
    #####:  117:	glob_draw_alpha = alpha&0xFF;
    #####:  118:	int bgr = draw_get_color();
    #####:  119:	SDL_SetRenderDrawColor(renderer,bgr&0xFF,(bgr>>8)&0xFF,(bgr>>16)&0xFF,alpha);
    #####:  120:}
------------------
draw_set_alpha:
    #####:  115:void draw_set_alpha(SDL_Renderer* renderer,int alpha)
        -:  116:{
    #####:  117:	glob_draw_alpha = alpha&0xFF;
    #####:  118:	int bgr = draw_get_color();
    #####:  119:	SDL_SetRenderDrawColor(renderer,bgr&0xFF,(bgr>>8)&0xFF,(bgr>>16)&0xFF,alpha);
    #####:  120:}
------------------
draw_set_alpha:
    #####:  115:void draw_set_alpha(SDL_Renderer* renderer,int alpha)
        -:  116:{
    #####:  117:	glob_draw_alpha = alpha&0xFF;
    #####:  118:	int bgr = draw_get_color();
    #####:  119:	SDL_SetRenderDrawColor(renderer,bgr&0xFF,(bgr>>8)&0xFF,(bgr>>16)&0xFF,alpha);
    #####:  120:}
------------------
     2014:  121:void draw_clear(SDL_Renderer* renderer,int bgr)
        -:  122:{
     2014:  123:	draw_set_color(renderer,bgr);
     2014:  124:	SDL_RenderClear(renderer);//fills whole with draw-color.	
     2014:  125:}
------------------
draw_clear:
     1007:  121:void draw_clear(SDL_Renderer* renderer,int bgr)
        -:  122:{
     1007:  123:	draw_set_color(renderer,bgr);
     1007:  124:	SDL_RenderClear(renderer);//fills whole with draw-color.	
     1007:  125:}
------------------
draw_clear:
     1007:  121:void draw_clear(SDL_Renderer* renderer,int bgr)
        -:  122:{
     1007:  123:	draw_set_color(renderer,bgr);
     1007:  124:	SDL_RenderClear(renderer);//fills whole with draw-color.	
     1007:  125:}
------------------
    #####:  126:void draw_clear_alpha(SDL_Renderer* renderer,int bgr,int alpha)
        -:  127:{
    #####:  128:	draw_set_alpha(renderer,alpha);
    #####:  129:	draw_clear(renderer,bgr);//invokes above function to avoid duplicate functionality.
    #####:  130:}
------------------
draw_clear_alpha:
    #####:  126:void draw_clear_alpha(SDL_Renderer* renderer,int bgr,int alpha)
        -:  127:{
    #####:  128:	draw_set_alpha(renderer,alpha);
    #####:  129:	draw_clear(renderer,bgr);//invokes above function to avoid duplicate functionality.
    #####:  130:}
------------------
draw_clear_alpha:
    #####:  126:void draw_clear_alpha(SDL_Renderer* renderer,int bgr,int alpha)
        -:  127:{
    #####:  128:	draw_set_alpha(renderer,alpha);
    #####:  129:	draw_clear(renderer,bgr);//invokes above function to avoid duplicate functionality.
    #####:  130:}
------------------
   535100:  131:void draw_rectangle(SDL_Renderer *renderer,int x1,int y1,int x2,int y2)
        -:  132:{
        -:  133:	//bug lookout: SDL_Rect is x,y,w,h, and draw_rectangle is x1,y1,x2,y2.
        -:  134:	SDL_Rect r;// = {.x=32,.y=64,.w=480,.h=480};
   535100:  135:	r.x = x1;
   535100:  136:	r.y = y1;
   535100:  137:	r.w = x2-x1;//convert x2,y2 to w,h
   535100:  138:	r.h = y2-y1;
   535100:  139:	SDL_RenderFillRect(renderer,&r);
   535100:  140:}
------------------
draw_rectangle:
   267550:  131:void draw_rectangle(SDL_Renderer *renderer,int x1,int y1,int x2,int y2)
        -:  132:{
        -:  133:	//bug lookout: SDL_Rect is x,y,w,h, and draw_rectangle is x1,y1,x2,y2.
        -:  134:	SDL_Rect r;// = {.x=32,.y=64,.w=480,.h=480};
   267550:  135:	r.x = x1;
   267550:  136:	r.y = y1;
   267550:  137:	r.w = x2-x1;//convert x2,y2 to w,h
   267550:  138:	r.h = y2-y1;
   267550:  139:	SDL_RenderFillRect(renderer,&r);
   267550:  140:}
------------------
draw_rectangle:
   267550:  131:void draw_rectangle(SDL_Renderer *renderer,int x1,int y1,int x2,int y2)
        -:  132:{
        -:  133:	//bug lookout: SDL_Rect is x,y,w,h, and draw_rectangle is x1,y1,x2,y2.
        -:  134:	SDL_Rect r;// = {.x=32,.y=64,.w=480,.h=480};
   267550:  135:	r.x = x1;
   267550:  136:	r.y = y1;
   267550:  137:	r.w = x2-x1;//convert x2,y2 to w,h
   267550:  138:	r.h = y2-y1;
   267550:  139:	SDL_RenderFillRect(renderer,&r);
   267550:  140:}
------------------
   535100:  141:void draw_rectangle_color(SDL_Renderer *renderer,int x1,int y1,int x2,int y2,int bgr)
        -:  142:{
   535100:  143:	int tmp=draw_get_color();
   535100:  144:	draw_set_color(renderer,bgr);
   535100:  145:	draw_rectangle(renderer,x1,y1,x2,y2);
   535100:  146:	draw_set_color(renderer,tmp);
   535100:  147:}
------------------
draw_rectangle_color:
   267550:  141:void draw_rectangle_color(SDL_Renderer *renderer,int x1,int y1,int x2,int y2,int bgr)
        -:  142:{
   267550:  143:	int tmp=draw_get_color();
   267550:  144:	draw_set_color(renderer,bgr);
   267550:  145:	draw_rectangle(renderer,x1,y1,x2,y2);
   267550:  146:	draw_set_color(renderer,tmp);
   267550:  147:}
------------------
draw_rectangle_color:
   267550:  141:void draw_rectangle_color(SDL_Renderer *renderer,int x1,int y1,int x2,int y2,int bgr)
        -:  142:{
   267550:  143:	int tmp=draw_get_color();
   267550:  144:	draw_set_color(renderer,bgr);
   267550:  145:	draw_rectangle(renderer,x1,y1,x2,y2);
   267550:  146:	draw_set_color(renderer,tmp);
   267550:  147:}
------------------
   798956:  148:void draw_image(SDL_Renderer *renderer,int x1,int y1,int x2,int y2,SDL_Texture *texture)
        -:  149:{
        -:  150:	//draws the whole texture into a rectangle, stretch-to-fit.
        -:  151:	SDL_Rect r;// = {.x=32,.y=64,.w=480,.h=480};
   798956:  152:	r.x = x1;
   798956:  153:	r.y = y1;
   798956:  154:	r.w = x2-x1;//convert x2,y2 to w,h
   798956:  155:	r.h = y2-y1;
   798956:  156:	int col=glob_draw_color;
   798956:  157:	SDL_SetTextureColorMod(texture,col&0xFF,(col>>8)&0xFF,(col>>16)&0xFF);
   798956:  158:	SDL_RenderCopy(renderer,texture,NULL,&r);//texture fill whole renderer.
   798956:  159:}
------------------
draw_image:
   399478:  148:void draw_image(SDL_Renderer *renderer,int x1,int y1,int x2,int y2,SDL_Texture *texture)
        -:  149:{
        -:  150:	//draws the whole texture into a rectangle, stretch-to-fit.
        -:  151:	SDL_Rect r;// = {.x=32,.y=64,.w=480,.h=480};
   399478:  152:	r.x = x1;
   399478:  153:	r.y = y1;
   399478:  154:	r.w = x2-x1;//convert x2,y2 to w,h
   399478:  155:	r.h = y2-y1;
   399478:  156:	int col=glob_draw_color;
   399478:  157:	SDL_SetTextureColorMod(texture,col&0xFF,(col>>8)&0xFF,(col>>16)&0xFF);
   399478:  158:	SDL_RenderCopy(renderer,texture,NULL,&r);//texture fill whole renderer.
   399478:  159:}
------------------
draw_image:
   399478:  148:void draw_image(SDL_Renderer *renderer,int x1,int y1,int x2,int y2,SDL_Texture *texture)
        -:  149:{
        -:  150:	//draws the whole texture into a rectangle, stretch-to-fit.
        -:  151:	SDL_Rect r;// = {.x=32,.y=64,.w=480,.h=480};
   399478:  152:	r.x = x1;
   399478:  153:	r.y = y1;
   399478:  154:	r.w = x2-x1;//convert x2,y2 to w,h
   399478:  155:	r.h = y2-y1;
   399478:  156:	int col=glob_draw_color;
   399478:  157:	SDL_SetTextureColorMod(texture,col&0xFF,(col>>8)&0xFF,(col>>16)&0xFF);
   399478:  158:	SDL_RenderCopy(renderer,texture,NULL,&r);//texture fill whole renderer.
   399478:  159:}
------------------
   714236:  160:void draw_image_part(SDL_Renderer *renderer,int x1,int y1,int x2,int y2,SDL_Texture *texture,int left,int top,int width,int height)
        -:  161:{
        -:  162:	SDL_Rect r;
   714236:  163:	r.x = x1;
   714236:  164:	r.y = y1;
   714236:  165:	r.w = x2-x1;//convert x2,y2 to w,h
   714236:  166:	r.h = y2-y1;
        -:  167:	SDL_Rect s;
   714236:  168:	s.x = left;
   714236:  169:	s.y = top;
   714236:  170:	s.w = width;
   714236:  171:	s.h = height;
   714236:  172:	int col=glob_draw_color;
   714236:  173:	SDL_SetTextureColorMod(texture,col&0xFF,(col>>8)&0xFF,(col>>16)&0xFF);
   714236:  174:	SDL_RenderCopy(renderer,texture,&s,&r);
   714236:  175:}
------------------
draw_image_part:
   357118:  160:void draw_image_part(SDL_Renderer *renderer,int x1,int y1,int x2,int y2,SDL_Texture *texture,int left,int top,int width,int height)
        -:  161:{
        -:  162:	SDL_Rect r;
   357118:  163:	r.x = x1;
   357118:  164:	r.y = y1;
   357118:  165:	r.w = x2-x1;//convert x2,y2 to w,h
   357118:  166:	r.h = y2-y1;
        -:  167:	SDL_Rect s;
   357118:  168:	s.x = left;
   357118:  169:	s.y = top;
   357118:  170:	s.w = width;
   357118:  171:	s.h = height;
   357118:  172:	int col=glob_draw_color;
   357118:  173:	SDL_SetTextureColorMod(texture,col&0xFF,(col>>8)&0xFF,(col>>16)&0xFF);
   357118:  174:	SDL_RenderCopy(renderer,texture,&s,&r);
   357118:  175:}
------------------
draw_image_part:
   357118:  160:void draw_image_part(SDL_Renderer *renderer,int x1,int y1,int x2,int y2,SDL_Texture *texture,int left,int top,int width,int height)
        -:  161:{
        -:  162:	SDL_Rect r;
   357118:  163:	r.x = x1;
   357118:  164:	r.y = y1;
   357118:  165:	r.w = x2-x1;//convert x2,y2 to w,h
   357118:  166:	r.h = y2-y1;
        -:  167:	SDL_Rect s;
   357118:  168:	s.x = left;
   357118:  169:	s.y = top;
   357118:  170:	s.w = width;
   357118:  171:	s.h = height;
   357118:  172:	int col=glob_draw_color;
   357118:  173:	SDL_SetTextureColorMod(texture,col&0xFF,(col>>8)&0xFF,(col>>16)&0xFF);
   357118:  174:	SDL_RenderCopy(renderer,texture,&s,&r);
   357118:  175:}
------------------
    39842:  176:void draw_text(SDL_Renderer *renderer,int x,int y,int w,int h,SDL_Texture *font,char* str,int fontw,int fonth)
        -:  177:{
        -:  178:	//"#" = newline.
        -:  179:	//"##" = prints "#" with newline (unfinished: without newline).
    39842:  180:	int len=strlen(str);
    39842:  181:	int ch=0;
    39842:  182:	int xo=0;
    39842:  183:	int yo=0;
    39842:  184:	int nl=((int)"#"[0])-32;//should I be proud or scared of myself?
   182228:  185:	for (int i=0; i<len; i++)
        -:  186:	{
   142386:  187:		ch = ((int)str[i])-32;
   142386:  188:		if (ch == nl)
        -:  189:		{
    #####:  190:			if (!(((int)str[i+1])-32 == nl))//next char is not nl.
        -:  191:			{
    #####:  192:				xo = 0;
    #####:  193:				yo += h;
    #####:  194:				continue;
        -:  195:			}
        -:  196:		}
   427158:  197:		draw_image_part(renderer,
   142386:  198:			x+xo+0,y+yo,x+xo+w,y+yo+h,
        -:  199:			font,
        -:  200:			ch*fontw,0,fontw,fonth);
   142386:  201:		xo += w;
        -:  202:	}
    39842:  203:}
------------------
draw_text:
    19921:  176:void draw_text(SDL_Renderer *renderer,int x,int y,int w,int h,SDL_Texture *font,char* str,int fontw,int fonth)
        -:  177:{
        -:  178:	//"#" = newline.
        -:  179:	//"##" = prints "#" with newline (unfinished: without newline).
    19921:  180:	int len=strlen(str);
    19921:  181:	int ch=0;
    19921:  182:	int xo=0;
    19921:  183:	int yo=0;
    19921:  184:	int nl=((int)"#"[0])-32;//should I be proud or scared of myself?
    91114:  185:	for (int i=0; i<len; i++)
        -:  186:	{
    71193:  187:		ch = ((int)str[i])-32;
    71193:  188:		if (ch == nl)
        -:  189:		{
    #####:  190:			if (!(((int)str[i+1])-32 == nl))//next char is not nl.
        -:  191:			{
    #####:  192:				xo = 0;
    #####:  193:				yo += h;
    #####:  194:				continue;
        -:  195:			}
        -:  196:		}
   213579:  197:		draw_image_part(renderer,
    71193:  198:			x+xo+0,y+yo,x+xo+w,y+yo+h,
        -:  199:			font,
        -:  200:			ch*fontw,0,fontw,fonth);
    71193:  201:		xo += w;
        -:  202:	}
    19921:  203:}
------------------
draw_text:
    19921:  176:void draw_text(SDL_Renderer *renderer,int x,int y,int w,int h,SDL_Texture *font,char* str,int fontw,int fonth)
        -:  177:{
        -:  178:	//"#" = newline.
        -:  179:	//"##" = prints "#" with newline (unfinished: without newline).
    19921:  180:	int len=strlen(str);
    19921:  181:	int ch=0;
    19921:  182:	int xo=0;
    19921:  183:	int yo=0;
    19921:  184:	int nl=((int)"#"[0])-32;//should I be proud or scared of myself?
    91114:  185:	for (int i=0; i<len; i++)
        -:  186:	{
    71193:  187:		ch = ((int)str[i])-32;
    71193:  188:		if (ch == nl)
        -:  189:		{
    #####:  190:			if (!(((int)str[i+1])-32 == nl))//next char is not nl.
        -:  191:			{
    #####:  192:				xo = 0;
    #####:  193:				yo += h;
    #####:  194:				continue;
        -:  195:			}
        -:  196:		}
   213579:  197:		draw_image_part(renderer,
    71193:  198:			x+xo+0,y+yo,x+xo+w,y+yo+h,
        -:  199:			font,
        -:  200:			ch*fontw,0,fontw,fonth);
    71193:  201:		xo += w;
        -:  202:	}
    19921:  203:}
------------------
    39842:  204:void draw_text_color(SDL_Renderer *renderer,int x,int y,int w,int h,SDL_Texture *font,char* str,int fontw,int fonth,int color)
        -:  205:{
    39842:  206:	int dgc=draw_get_color();
    39842:  207:	draw_set_color(renderer,color);
    39842:  208:	draw_text(renderer,x,y,w,h,font,str,fontw,fonth);
    39842:  209:	draw_set_color(renderer,dgc);
    39842:  210:}
------------------
draw_text_color:
    19921:  204:void draw_text_color(SDL_Renderer *renderer,int x,int y,int w,int h,SDL_Texture *font,char* str,int fontw,int fonth,int color)
        -:  205:{
    19921:  206:	int dgc=draw_get_color();
    19921:  207:	draw_set_color(renderer,color);
    19921:  208:	draw_text(renderer,x,y,w,h,font,str,fontw,fonth);
    19921:  209:	draw_set_color(renderer,dgc);
    19921:  210:}
------------------
draw_text_color:
    19921:  204:void draw_text_color(SDL_Renderer *renderer,int x,int y,int w,int h,SDL_Texture *font,char* str,int fontw,int fonth,int color)
        -:  205:{
    19921:  206:	int dgc=draw_get_color();
    19921:  207:	draw_set_color(renderer,color);
    19921:  208:	draw_text(renderer,x,y,w,h,font,str,fontw,fonth);
    19921:  209:	draw_set_color(renderer,dgc);
    19921:  210:}
------------------
    #####:  211:int keyboard_check(int key)
        -:  212:{
    #####:  213:	return glob_vk_down;
        -:  214:}
------------------
keyboard_check:
    #####:  211:int keyboard_check(int key)
        -:  212:{
    #####:  213:	return glob_vk_down;
        -:  214:}
------------------
keyboard_check:
    #####:  211:int keyboard_check(int key)
        -:  212:{
    #####:  213:	return glob_vk_down;
        -:  214:}
------------------
    #####:  215:int keyboard_check_pressed(int key)
        -:  216:{
    #####:  217:	return glob_vk_down;
        -:  218:}
------------------
keyboard_check_pressed:
    #####:  215:int keyboard_check_pressed(int key)
        -:  216:{
    #####:  217:	return glob_vk_down;
        -:  218:}
------------------
keyboard_check_pressed:
    #####:  215:int keyboard_check_pressed(int key)
        -:  216:{
    #####:  217:	return glob_vk_down;
        -:  218:}
------------------
    #####:  219:int keyboard_check_released(int key)
        -:  220:{
    #####:  221:	return glob_vk_down;
        -:  222:}
------------------
keyboard_check_released:
    #####:  219:int keyboard_check_released(int key)
        -:  220:{
    #####:  221:	return glob_vk_down;
        -:  222:}
------------------
keyboard_check_released:
    #####:  219:int keyboard_check_released(int key)
        -:  220:{
    #####:  221:	return glob_vk_down;
        -:  222:}
------------------
    13370:  223:int mux_int(int nth,...)
        -:  224:{
        -:  225:	//Multiplexer for ints.
        -:  226:	//Returns the nth argument.
        -:  227:	va_list args;
    13370:  228:	va_start(args,nth);
    13370:  229:	int ret = va_arg(args,int);
    36290:  230:	for (int i=0; i<nth; i++)
        -:  231:	{
    22920:  232:		ret = va_arg(args,int);
        -:  233:	}
    13370:  234:	va_end(args);
    13370:  235:	return ret;
        -:  236:}
------------------
mux_int:
     6685:  223:int mux_int(int nth,...)
        -:  224:{
        -:  225:	//Multiplexer for ints.
        -:  226:	//Returns the nth argument.
        -:  227:	va_list args;
     6685:  228:	va_start(args,nth);
     6685:  229:	int ret = va_arg(args,int);
    18145:  230:	for (int i=0; i<nth; i++)
        -:  231:	{
    11460:  232:		ret = va_arg(args,int);
        -:  233:	}
     6685:  234:	va_end(args);
     6685:  235:	return ret;
        -:  236:}
------------------
mux_int:
     6685:  223:int mux_int(int nth,...)
        -:  224:{
        -:  225:	//Multiplexer for ints.
        -:  226:	//Returns the nth argument.
        -:  227:	va_list args;
     6685:  228:	va_start(args,nth);
     6685:  229:	int ret = va_arg(args,int);
    18145:  230:	for (int i=0; i<nth; i++)
        -:  231:	{
    11460:  232:		ret = va_arg(args,int);
        -:  233:	}
     6685:  234:	va_end(args);
     6685:  235:	return ret;
        -:  236:}
------------------
     9550:  237:char* mux_str(int nth,...)
        -:  238:{
        -:  239:	//Multiplexer for ints.
        -:  240:	//Returns the nth argument.
        -:  241:	va_list args;
     9550:  242:	va_start(args,nth);
     9550:  243:	char* ret = va_arg(args,int);
    22990:  244:	for (int i=0; i<nth; i++)
        -:  245:	{
    13440:  246:		ret = va_arg(args,char*);
        -:  247:	}
     9550:  248:	va_end(args);
     9550:  249:	return ret;
        -:  250:}
------------------
mux_str:
     4775:  237:char* mux_str(int nth,...)
        -:  238:{
        -:  239:	//Multiplexer for ints.
        -:  240:	//Returns the nth argument.
        -:  241:	va_list args;
     4775:  242:	va_start(args,nth);
     4775:  243:	char* ret = va_arg(args,int);
    11495:  244:	for (int i=0; i<nth; i++)
        -:  245:	{
     6720:  246:		ret = va_arg(args,char*);
        -:  247:	}
     4775:  248:	va_end(args);
     4775:  249:	return ret;
        -:  250:}
------------------
mux_str:
     4775:  237:char* mux_str(int nth,...)
        -:  238:{
        -:  239:	//Multiplexer for ints.
        -:  240:	//Returns the nth argument.
        -:  241:	va_list args;
     4775:  242:	va_start(args,nth);
     4775:  243:	char* ret = va_arg(args,int);
    11495:  244:	for (int i=0; i<nth; i++)
        -:  245:	{
     6720:  246:		ret = va_arg(args,char*);
        -:  247:	}
     4775:  248:	va_end(args);
     4775:  249:	return ret;
        -:  250:}
------------------
    #####:  251:SDL_Texture* mux_sdltex(int nth,...)
        -:  252:{
        -:  253:	//Multiplexer for SDL_Texture pointers.
        -:  254:	//Returns the nth argument.
        -:  255:	va_list args;
    #####:  256:	va_start(args,nth);
    #####:  257:	int ret = va_arg(args,int);
    #####:  258:	for (int i=0; i<nth; i++)
        -:  259:	{
    #####:  260:		ret = va_arg(args,SDL_Texture*);
        -:  261:	}
    #####:  262:	va_end(args);
    #####:  263:	return ret;
        -:  264:}
------------------
mux_sdltex:
    #####:  251:SDL_Texture* mux_sdltex(int nth,...)
        -:  252:{
        -:  253:	//Multiplexer for SDL_Texture pointers.
        -:  254:	//Returns the nth argument.
        -:  255:	va_list args;
    #####:  256:	va_start(args,nth);
    #####:  257:	int ret = va_arg(args,int);
    #####:  258:	for (int i=0; i<nth; i++)
        -:  259:	{
    #####:  260:		ret = va_arg(args,SDL_Texture*);
        -:  261:	}
    #####:  262:	va_end(args);
    #####:  263:	return ret;
        -:  264:}
------------------
mux_sdltex:
    #####:  251:SDL_Texture* mux_sdltex(int nth,...)
        -:  252:{
        -:  253:	//Multiplexer for SDL_Texture pointers.
        -:  254:	//Returns the nth argument.
        -:  255:	va_list args;
    #####:  256:	va_start(args,nth);
    #####:  257:	int ret = va_arg(args,int);
    #####:  258:	for (int i=0; i<nth; i++)
        -:  259:	{
    #####:  260:		ret = va_arg(args,SDL_Texture*);
        -:  261:	}
    #####:  262:	va_end(args);
    #####:  263:	return ret;
        -:  264:}
------------------
    #####:  265:int pos_int(int num,int val,...)
        -:  266:{
        -:  267:	//A demultiplexer variant for ints.
        -:  268:	//Returns the position a value appears in, or -1 if not.
        -:  269:	
        -:  270:	//untested.
        -:  271:	
        -:  272:	va_list args;
    #####:  273:	va_start(args,val);
    #####:  274:	int ret = va_arg(args,int);
    #####:  275:	int i=0;
        -:  276:	int tmp;
    #####:  277:	for (i=0; i<num; i++)
        -:  278:	{
    #####:  279:		tmp = va_arg(args,int);
    #####:  280:		if (val == tmp)
        -:  281:		{
    #####:  282:			va_end(args);
    #####:  283:			return i;
        -:  284:		}
        -:  285:	}
    #####:  286:	va_end(args);
    #####:  287:	return -1;
        -:  288:}
------------------
pos_int:
    #####:  265:int pos_int(int num,int val,...)
        -:  266:{
        -:  267:	//A demultiplexer variant for ints.
        -:  268:	//Returns the position a value appears in, or -1 if not.
        -:  269:	
        -:  270:	//untested.
        -:  271:	
        -:  272:	va_list args;
    #####:  273:	va_start(args,val);
    #####:  274:	int ret = va_arg(args,int);
    #####:  275:	int i=0;
        -:  276:	int tmp;
    #####:  277:	for (i=0; i<num; i++)
        -:  278:	{
    #####:  279:		tmp = va_arg(args,int);
    #####:  280:		if (val == tmp)
        -:  281:		{
    #####:  282:			va_end(args);
    #####:  283:			return i;
        -:  284:		}
        -:  285:	}
    #####:  286:	va_end(args);
    #####:  287:	return -1;
        -:  288:}
------------------
pos_int:
    #####:  265:int pos_int(int num,int val,...)
        -:  266:{
        -:  267:	//A demultiplexer variant for ints.
        -:  268:	//Returns the position a value appears in, or -1 if not.
        -:  269:	
        -:  270:	//untested.
        -:  271:	
        -:  272:	va_list args;
    #####:  273:	va_start(args,val);
    #####:  274:	int ret = va_arg(args,int);
    #####:  275:	int i=0;
        -:  276:	int tmp;
    #####:  277:	for (i=0; i<num; i++)
        -:  278:	{
    #####:  279:		tmp = va_arg(args,int);
    #####:  280:		if (val == tmp)
        -:  281:		{
    #####:  282:			va_end(args);
    #####:  283:			return i;
        -:  284:		}
        -:  285:	}
    #####:  286:	va_end(args);
    #####:  287:	return -1;
        -:  288:}
------------------
   488960:  289:int BG(int val,int nth)
        -:  290:{
   488960:  291:	return (val>>nth)&1;
        -:  292:}
------------------
BG:
   244480:  289:int BG(int val,int nth)
        -:  290:{
   244480:  291:	return (val>>nth)&1;
        -:  292:}
------------------
BG:
   244480:  289:int BG(int val,int nth)
        -:  290:{
   244480:  291:	return (val>>nth)&1;
        -:  292:}
------------------
     7640:  293:int BGG(int val,int size,int nth)
        -:  294:{
     7640:  295:	return (val>>(nth*size))&((1<<size)-1);
        -:  296:}
------------------
BGG:
     3820:  293:int BGG(int val,int size,int nth)
        -:  294:{
     3820:  295:	return (val>>(nth*size))&((1<<size)-1);
        -:  296:}
------------------
BGG:
     3820:  293:int BGG(int val,int size,int nth)
        -:  294:{
     3820:  295:	return (val>>(nth*size))&((1<<size)-1);
        -:  296:}
------------------
        4:  297:int sqr(int v)
        -:  298:{
        4:  299:	return v*v;
        -:  300:}
------------------
sqr:
        2:  297:int sqr(int v)
        -:  298:{
        2:  299:	return v*v;
        -:  300:}
------------------
sqr:
        2:  297:int sqr(int v)
        -:  298:{
        2:  299:	return v*v;
        -:  300:}
------------------
    12168:  301:double degtorad(double deg)
        -:  302:{
    12168:  303:	return (deg/180)*PI;
        -:  304:}
------------------
degtorad:
     6084:  301:double degtorad(double deg)
        -:  302:{
     6084:  303:	return (deg/180)*PI;
        -:  304:}
------------------
degtorad:
     6084:  301:double degtorad(double deg)
        -:  302:{
     6084:  303:	return (deg/180)*PI;
        -:  304:}
------------------
    #####:  305:double radtodeg(double rad)
        -:  306:{
    #####:  307:	return (rad/PI)*180;
        -:  308:}
------------------
radtodeg:
    #####:  305:double radtodeg(double rad)
        -:  306:{
    #####:  307:	return (rad/PI)*180;
        -:  308:}
------------------
radtodeg:
    #####:  305:double radtodeg(double rad)
        -:  306:{
    #####:  307:	return (rad/PI)*180;
        -:  308:}
------------------
     8840:  309:double dcos(double deg)
        -:  310:{
     8840:  311:	return cos(degtorad(deg));
        -:  312:}
------------------
dcos:
     4420:  309:double dcos(double deg)
        -:  310:{
     4420:  311:	return cos(degtorad(deg));
        -:  312:}
------------------
dcos:
     4420:  309:double dcos(double deg)
        -:  310:{
     4420:  311:	return cos(degtorad(deg));
        -:  312:}
------------------
     3328:  313:double dsin(double deg)
        -:  314:{
     3328:  315:	return sin(degtorad(deg));
        -:  316:}
------------------
dsin:
     1664:  313:double dsin(double deg)
        -:  314:{
     1664:  315:	return sin(degtorad(deg));
        -:  316:}
------------------
dsin:
     1664:  313:double dsin(double deg)
        -:  314:{
     1664:  315:	return sin(degtorad(deg));
        -:  316:}
------------------
    26898:  317:Uint64 get_timer()
        -:  318:{
    26898:  319:	return SDL_GetTicks64();
        -:  320:}
------------------
get_timer:
    13449:  317:Uint64 get_timer()
        -:  318:{
    13449:  319:	return SDL_GetTicks64();
        -:  320:}
------------------
get_timer:
    13449:  317:Uint64 get_timer()
        -:  318:{
    13449:  319:	return SDL_GetTicks64();
        -:  320:}
------------------
    #####:  321:int point_in_rectangle(int px,int py,int rx1,int ry1,int rx2,int ry2)
        -:  322:{
    #####:  323:	return ((px>=rx1 && px<rx2) && (py>=ry1 && py<ry2));
        -:  324:}
------------------
point_in_rectangle:
    #####:  321:int point_in_rectangle(int px,int py,int rx1,int ry1,int rx2,int ry2)
        -:  322:{
    #####:  323:	return ((px>=rx1 && px<rx2) && (py>=ry1 && py<ry2));
        -:  324:}
------------------
point_in_rectangle:
    #####:  321:int point_in_rectangle(int px,int py,int rx1,int ry1,int rx2,int ry2)
        -:  322:{
    #####:  323:	return ((px>=rx1 && px<rx2) && (py>=ry1 && py<ry2));
        -:  324:}
------------------
    #####:  325:int rectangle_in_rectangle(int sx1,int sy1,int sx2,int sy2,int dx1,int dy1,int dx2,int dy2)
        -:  326:{
        -:  327:	//returns: 0=outside, 1=inside, 2=partially
        -:  328:	//ensure that *x2,*y2 are larger than *x1,*y1 for best results.
    #####:  329:	int tmp=0;
    #####:  330:	tmp += point_in_rectangle(sx1,sy1,dx1,dy1,dx2,dy2);
    #####:  331:	tmp += point_in_rectangle(sx2,sy1,dx1,dy1,dx2,dy2);
    #####:  332:	tmp += point_in_rectangle(sx1,sy2,dx1,dy1,dx2,dy2);
    #####:  333:	tmp += point_in_rectangle(sx2,sy2,dx1,dy1,dx2,dy2);
    #####:  334:	     if (tmp == 0) {return 0;}
    #####:  335:	else if (tmp == 4) {return 1;}
    #####:  336:	else {return 2;}
        -:  337:}
------------------
rectangle_in_rectangle:
    #####:  325:int rectangle_in_rectangle(int sx1,int sy1,int sx2,int sy2,int dx1,int dy1,int dx2,int dy2)
        -:  326:{
        -:  327:	//returns: 0=outside, 1=inside, 2=partially
        -:  328:	//ensure that *x2,*y2 are larger than *x1,*y1 for best results.
    #####:  329:	int tmp=0;
    #####:  330:	tmp += point_in_rectangle(sx1,sy1,dx1,dy1,dx2,dy2);
    #####:  331:	tmp += point_in_rectangle(sx2,sy1,dx1,dy1,dx2,dy2);
    #####:  332:	tmp += point_in_rectangle(sx1,sy2,dx1,dy1,dx2,dy2);
    #####:  333:	tmp += point_in_rectangle(sx2,sy2,dx1,dy1,dx2,dy2);
    #####:  334:	     if (tmp == 0) {return 0;}
    #####:  335:	else if (tmp == 4) {return 1;}
    #####:  336:	else {return 2;}
        -:  337:}
------------------
rectangle_in_rectangle:
    #####:  325:int rectangle_in_rectangle(int sx1,int sy1,int sx2,int sy2,int dx1,int dy1,int dx2,int dy2)
        -:  326:{
        -:  327:	//returns: 0=outside, 1=inside, 2=partially
        -:  328:	//ensure that *x2,*y2 are larger than *x1,*y1 for best results.
    #####:  329:	int tmp=0;
    #####:  330:	tmp += point_in_rectangle(sx1,sy1,dx1,dy1,dx2,dy2);
    #####:  331:	tmp += point_in_rectangle(sx2,sy1,dx1,dy1,dx2,dy2);
    #####:  332:	tmp += point_in_rectangle(sx1,sy2,dx1,dy1,dx2,dy2);
    #####:  333:	tmp += point_in_rectangle(sx2,sy2,dx1,dy1,dx2,dy2);
    #####:  334:	     if (tmp == 0) {return 0;}
    #####:  335:	else if (tmp == 4) {return 1;}
    #####:  336:	else {return 2;}
        -:  337:}
------------------
     5730:  338:int string_pos(char *substr,char *str)
        -:  339:{
        -:  340:	//finds single-char substr in str.
        -:  341:	//todo: find multiple-char substr in str.
        -:  342:	//if not found, returns -1
     5730:  343:	char *a = substr[0];
        -:  344:	char *b;// = str[0];
     5730:  345:	int len=strlen(str);
     5730:  346:	int ret=0;
    40110:  347:	for (int i=0; i<len; i++)
        -:  348:	{
    40110:  349:		b = str[i];
    40110:  350:		if ((char)a == (char)b)
        -:  351:		//if (strcmp((const char*)&a,(const char*)&b)==0)
        -:  352:		{
     5730:  353:			return i;
        -:  354:		}
        -:  355:	}
    #####:  356:	return -1;
        -:  357:}
------------------
string_pos:
     2865:  338:int string_pos(char *substr,char *str)
        -:  339:{
        -:  340:	//finds single-char substr in str.
        -:  341:	//todo: find multiple-char substr in str.
        -:  342:	//if not found, returns -1
     2865:  343:	char *a = substr[0];
        -:  344:	char *b;// = str[0];
     2865:  345:	int len=strlen(str);
     2865:  346:	int ret=0;
    20055:  347:	for (int i=0; i<len; i++)
        -:  348:	{
    20055:  349:		b = str[i];
    20055:  350:		if ((char)a == (char)b)
        -:  351:		//if (strcmp((const char*)&a,(const char*)&b)==0)
        -:  352:		{
     2865:  353:			return i;
        -:  354:		}
        -:  355:	}
    #####:  356:	return -1;
        -:  357:}
------------------
string_pos:
     2865:  338:int string_pos(char *substr,char *str)
        -:  339:{
        -:  340:	//finds single-char substr in str.
        -:  341:	//todo: find multiple-char substr in str.
        -:  342:	//if not found, returns -1
     2865:  343:	char *a = substr[0];
        -:  344:	char *b;// = str[0];
     2865:  345:	int len=strlen(str);
     2865:  346:	int ret=0;
    20055:  347:	for (int i=0; i<len; i++)
        -:  348:	{
    20055:  349:		b = str[i];
    20055:  350:		if ((char)a == (char)b)
        -:  351:		//if (strcmp((const char*)&a,(const char*)&b)==0)
        -:  352:		{
     2865:  353:			return i;
        -:  354:		}
        -:  355:	}
    #####:  356:	return -1;
        -:  357:}
------------------
    #####:  358:double darctan2(int y,int x)
        -:  359:{
    #####:  360:	return radtodeg(atan2(y,x));
        -:  361:}
------------------
darctan2:
    #####:  358:double darctan2(int y,int x)
        -:  359:{
    #####:  360:	return radtodeg(atan2(y,x));
        -:  361:}
------------------
darctan2:
    #####:  358:double darctan2(int y,int x)
        -:  359:{
    #####:  360:	return radtodeg(atan2(y,x));
        -:  361:}
------------------
    #####:  362:double cartodir(int x,int y)
        -:  363:{
        -:  364:	//return (darctan2(y,x)+360.0)%360.0;
    #####:  365:	double ret = darctan2(y,x)+360.0;
    #####:  366:	if (ret >= 360.0) {ret -= 360.0;}
    #####:  367:	return ret;
        -:  368:}
------------------
cartodir:
    #####:  362:double cartodir(int x,int y)
        -:  363:{
        -:  364:	//return (darctan2(y,x)+360.0)%360.0;
    #####:  365:	double ret = darctan2(y,x)+360.0;
    #####:  366:	if (ret >= 360.0) {ret -= 360.0;}
    #####:  367:	return ret;
        -:  368:}
------------------
cartodir:
    #####:  362:double cartodir(int x,int y)
        -:  363:{
        -:  364:	//return (darctan2(y,x)+360.0)%360.0;
    #####:  365:	double ret = darctan2(y,x)+360.0;
    #####:  366:	if (ret >= 360.0) {ret -= 360.0;}
    #####:  367:	return ret;
        -:  368:}
------------------
    #####:  369:void game_level_load(int lvl,int lvlmax)
        -:  370:{
        -:  371:	//done below.
    #####:  372:}
------------------
game_level_load:
    #####:  369:void game_level_load(int lvl,int lvlmax)
        -:  370:{
        -:  371:	//done below.
    #####:  372:}
------------------
game_level_load:
    #####:  369:void game_level_load(int lvl,int lvlmax)
        -:  370:{
        -:  371:	//done below.
    #####:  372:}
------------------
        2:  373:void level_load(byte arr[],int siz,int count,int layers)
        -:  374:{
        2:  375:	FILE *fil = fopen("level.dat","rb");
   524290:  376:	for (int i=0; i<siz*count*layers; i++)
        -:  377:	{
   524288:  378:		arr[i] = 0;
        -:  379:	}
        2:  380:	fread(arr,siz*count*layers,1,fil);
        2:  381:	fclose(fil);
        2:  382:}
------------------
level_load:
        1:  373:void level_load(byte arr[],int siz,int count,int layers)
        -:  374:{
        1:  375:	FILE *fil = fopen("level.dat","rb");
   262145:  376:	for (int i=0; i<siz*count*layers; i++)
        -:  377:	{
   262144:  378:		arr[i] = 0;
        -:  379:	}
        1:  380:	fread(arr,siz*count*layers,1,fil);
        1:  381:	fclose(fil);
        1:  382:}
------------------
level_load:
        1:  373:void level_load(byte arr[],int siz,int count,int layers)
        -:  374:{
        1:  375:	FILE *fil = fopen("level.dat","rb");
   262145:  376:	for (int i=0; i<siz*count*layers; i++)
        -:  377:	{
   262144:  378:		arr[i] = 0;
        -:  379:	}
        1:  380:	fread(arr,siz*count*layers,1,fil);
        1:  381:	fclose(fil);
        1:  382:}
------------------
    #####:  383:void dev_tiled_to_leveldata(byte arr[])
        -:  384:{
        -:  385:	//Extracts Tiles (done) and Objects (unfinished (unnecessary if tiles and objects share tileset)).
    #####:  386:	printf("may take a while; please wait.\n");
    #####:  387:	glob_vk_f2=0;//fakes a keyboard press event (fails if held).
    #####:  388:	FILE *filin = fopen("tiled/cosc345-game.tmx","rb");
    #####:  389:	FILE *filout = fopen("level.dat","wb");
    #####:  390:	int layers=2;
    #####:  391:	int layersize=131072;
        -:  392:	//layersize=512;//debug only
    #####:  393:	int maxsize = layersize*layers;//131072
        -:  394:	byte array[262144];//tiles + objects.
    #####:  395:	int arrsiz=sizeof(array);
    #####:  396:	for (long i=0; i<maxsize; i++) {array[i] = 0;}
        -:  397:	//Discard input header.
    #####:  398:	fseek(filin,(long int)0x23D-0,SEEK_SET);//hardcoded; may bug out in future, so avoid renaming or resizing in Tiled project file.
        -:  399:	//Read Tiles and Objects.
    #####:  400:	byte comma=","[0];
    #####:  401:	int ch=0;
        -:  402:	byte entry[3];
        -:  403:	word val;
    #####:  404:	int counter=0;
    #####:  405:	int off=0;
    #####:  406:	int ij=0;
        -:  407:	//Extract and restructure.
    #####:  408:	for (int i=0; i<arrsiz; i++)
        -:  409:	{
    #####:  410:		ch=fgetc(filin);
    #####:  411:		for (int j=0; j<3; j++) {entry[j]=48;}
    #####:  412:		while ((ch==0xD) || (ch==0xA)) {ch=fgetc(filin);}
    #####:  413:		entry[2]=ch;
    #####:  414:		ch=fgetc(filin);
    #####:  415:		if (ch!=comma)
        -:  416:		{
    #####:  417:			entry[1]=entry[2];
    #####:  418:			entry[2]=ch;
    #####:  419:			ch=fgetc(filin);
    #####:  420:			if (ch!=comma)
        -:  421:			{
    #####:  422:				entry[0]=entry[1];
    #####:  423:				entry[1]=entry[2];
    #####:  424:				entry[2]=ch;
    #####:  425:				fgetc(filin);//important.
        -:  426:			}
        -:  427:		}
    #####:  428:		val^=val;
    #####:  429:		for (int j=0; j<3; j++) {val+=(entry[j]-48)*(byte)pow((double)10,(double)(2-j));}
    #####:  430:		printf("i=%i/%i (v=%i)\n",i,layersize,val);//comment out to speed up.
    #####:  431:		val-=(val==0)?(-0xFF):(1)&0xFF;
    #####:  432:		array[(((1<<(1<<1))<<1)<<((1|(1<<1)|(1<<(1<<1)))<<1))*(val>=(((1<<1)<<1)<<((1+1+1)<<1)))+(1<<(3<<(1<<1)))*(i>>(3<<(1<<1)))+(1<<(1<<3))*((i>>(1<<(1<<1)))&(3*(1<<(1<<1)|1)))+(1<<(1<<(1<<1)))*((i>>(1<<3))&(3*(1<<(1<<1)|1)))+(i&(3*(1<<(1<<1)|1)))]=val;//security through obscurity, or what? (it crashes the compiler...)
        -:  433:	}
        -:  434:	//Compress.
    #####:  435:	val^=val;
    #####:  436:	counter=0;
    #####:  437:	for (int i=0; i<layersize; i++)
        -:  438:	{
    #####:  439:		break;
        -:  440:	}
        -:  441:	//Write to file.
    #####:  442:	fwrite(array,maxsize,1,filout);
    #####:  443:	fclose(filin);
    #####:  444:	fclose(filout);
        -:  445:	//Re-load in-game.
    #####:  446:	level_load(arr,256,512,2);
    #####:  447:}
------------------
dev_tiled_to_leveldata:
    #####:  383:void dev_tiled_to_leveldata(byte arr[])
        -:  384:{
        -:  385:	//Extracts Tiles (done) and Objects (unfinished (unnecessary if tiles and objects share tileset)).
    #####:  386:	printf("may take a while; please wait.\n");
    #####:  387:	glob_vk_f2=0;//fakes a keyboard press event (fails if held).
    #####:  388:	FILE *filin = fopen("tiled/cosc345-game.tmx","rb");
    #####:  389:	FILE *filout = fopen("level.dat","wb");
    #####:  390:	int layers=2;
    #####:  391:	int layersize=131072;
        -:  392:	//layersize=512;//debug only
    #####:  393:	int maxsize = layersize*layers;//131072
        -:  394:	byte array[262144];//tiles + objects.
    #####:  395:	int arrsiz=sizeof(array);
    #####:  396:	for (long i=0; i<maxsize; i++) {array[i] = 0;}
        -:  397:	//Discard input header.
    #####:  398:	fseek(filin,(long int)0x23D-0,SEEK_SET);//hardcoded; may bug out in future, so avoid renaming or resizing in Tiled project file.
        -:  399:	//Read Tiles and Objects.
    #####:  400:	byte comma=","[0];
    #####:  401:	int ch=0;
        -:  402:	byte entry[3];
        -:  403:	word val;
    #####:  404:	int counter=0;
    #####:  405:	int off=0;
    #####:  406:	int ij=0;
        -:  407:	//Extract and restructure.
    #####:  408:	for (int i=0; i<arrsiz; i++)
        -:  409:	{
    #####:  410:		ch=fgetc(filin);
    #####:  411:		for (int j=0; j<3; j++) {entry[j]=48;}
    #####:  412:		while ((ch==0xD) || (ch==0xA)) {ch=fgetc(filin);}
    #####:  413:		entry[2]=ch;
    #####:  414:		ch=fgetc(filin);
    #####:  415:		if (ch!=comma)
        -:  416:		{
    #####:  417:			entry[1]=entry[2];
    #####:  418:			entry[2]=ch;
    #####:  419:			ch=fgetc(filin);
    #####:  420:			if (ch!=comma)
        -:  421:			{
    #####:  422:				entry[0]=entry[1];
    #####:  423:				entry[1]=entry[2];
    #####:  424:				entry[2]=ch;
    #####:  425:				fgetc(filin);//important.
        -:  426:			}
        -:  427:		}
    #####:  428:		val^=val;
    #####:  429:		for (int j=0; j<3; j++) {val+=(entry[j]-48)*(byte)pow((double)10,(double)(2-j));}
    #####:  430:		printf("i=%i/%i (v=%i)\n",i,layersize,val);//comment out to speed up.
    #####:  431:		val-=(val==0)?(-0xFF):(1)&0xFF;
    #####:  432:		array[(((1<<(1<<1))<<1)<<((1|(1<<1)|(1<<(1<<1)))<<1))*(val>=(((1<<1)<<1)<<((1+1+1)<<1)))+(1<<(3<<(1<<1)))*(i>>(3<<(1<<1)))+(1<<(1<<3))*((i>>(1<<(1<<1)))&(3*(1<<(1<<1)|1)))+(1<<(1<<(1<<1)))*((i>>(1<<3))&(3*(1<<(1<<1)|1)))+(i&(3*(1<<(1<<1)|1)))]=val;//security through obscurity, or what? (it crashes the compiler...)
        -:  433:	}
        -:  434:	//Compress.
    #####:  435:	val^=val;
    #####:  436:	counter=0;
    #####:  437:	for (int i=0; i<layersize; i++)
        -:  438:	{
    #####:  439:		break;
        -:  440:	}
        -:  441:	//Write to file.
    #####:  442:	fwrite(array,maxsize,1,filout);
    #####:  443:	fclose(filin);
    #####:  444:	fclose(filout);
        -:  445:	//Re-load in-game.
    #####:  446:	level_load(arr,256,512,2);
    #####:  447:}
------------------
dev_tiled_to_leveldata:
    #####:  383:void dev_tiled_to_leveldata(byte arr[])
        -:  384:{
        -:  385:	//Extracts Tiles (done) and Objects (unfinished (unnecessary if tiles and objects share tileset)).
    #####:  386:	printf("may take a while; please wait.\n");
    #####:  387:	glob_vk_f2=0;//fakes a keyboard press event (fails if held).
    #####:  388:	FILE *filin = fopen("tiled/cosc345-game.tmx","rb");
    #####:  389:	FILE *filout = fopen("level.dat","wb");
    #####:  390:	int layers=2;
    #####:  391:	int layersize=131072;
        -:  392:	//layersize=512;//debug only
    #####:  393:	int maxsize = layersize*layers;//131072
        -:  394:	byte array[262144];//tiles + objects.
    #####:  395:	int arrsiz=sizeof(array);
    #####:  396:	for (long i=0; i<maxsize; i++) {array[i] = 0;}
        -:  397:	//Discard input header.
    #####:  398:	fseek(filin,(long int)0x23D-0,SEEK_SET);//hardcoded; may bug out in future, so avoid renaming or resizing in Tiled project file.
        -:  399:	//Read Tiles and Objects.
    #####:  400:	byte comma=","[0];
    #####:  401:	int ch=0;
        -:  402:	byte entry[3];
        -:  403:	word val;
    #####:  404:	int counter=0;
    #####:  405:	int off=0;
    #####:  406:	int ij=0;
        -:  407:	//Extract and restructure.
    #####:  408:	for (int i=0; i<arrsiz; i++)
        -:  409:	{
    #####:  410:		ch=fgetc(filin);
    #####:  411:		for (int j=0; j<3; j++) {entry[j]=48;}
    #####:  412:		while ((ch==0xD) || (ch==0xA)) {ch=fgetc(filin);}
    #####:  413:		entry[2]=ch;
    #####:  414:		ch=fgetc(filin);
    #####:  415:		if (ch!=comma)
        -:  416:		{
    #####:  417:			entry[1]=entry[2];
    #####:  418:			entry[2]=ch;
    #####:  419:			ch=fgetc(filin);
    #####:  420:			if (ch!=comma)
        -:  421:			{
    #####:  422:				entry[0]=entry[1];
    #####:  423:				entry[1]=entry[2];
    #####:  424:				entry[2]=ch;
    #####:  425:				fgetc(filin);//important.
        -:  426:			}
        -:  427:		}
    #####:  428:		val^=val;
    #####:  429:		for (int j=0; j<3; j++) {val+=(entry[j]-48)*(byte)pow((double)10,(double)(2-j));}
    #####:  430:		printf("i=%i/%i (v=%i)\n",i,layersize,val);//comment out to speed up.
    #####:  431:		val-=(val==0)?(-0xFF):(1)&0xFF;
    #####:  432:		array[(((1<<(1<<1))<<1)<<((1|(1<<1)|(1<<(1<<1)))<<1))*(val>=(((1<<1)<<1)<<((1+1+1)<<1)))+(1<<(3<<(1<<1)))*(i>>(3<<(1<<1)))+(1<<(1<<3))*((i>>(1<<(1<<1)))&(3*(1<<(1<<1)|1)))+(1<<(1<<(1<<1)))*((i>>(1<<3))&(3*(1<<(1<<1)|1)))+(i&(3*(1<<(1<<1)|1)))]=val;//security through obscurity, or what? (it crashes the compiler...)
        -:  433:	}
        -:  434:	//Compress.
    #####:  435:	val^=val;
    #####:  436:	counter=0;
    #####:  437:	for (int i=0; i<layersize; i++)
        -:  438:	{
    #####:  439:		break;
        -:  440:	}
        -:  441:	//Write to file.
    #####:  442:	fwrite(array,maxsize,1,filout);
    #####:  443:	fclose(filin);
    #####:  444:	fclose(filout);
        -:  445:	//Re-load in-game.
    #####:  446:	level_load(arr,256,512,2);
    #####:  447:}
------------------
       28:  448:char* level_get_name(int lvl,char* ret)
        -:  449:{
        -:  450:	//Translates e.g level 8/256 to "Warrington".
        -:  451:	FILE *fil;
       28:  452:	fil=fopen("location.dat","rb");
       28:  453:	fseek(fil,(long int)lvl,SEEK_SET);
       28:  454:	int tmp=(int)fgetc(fil);
       28:  455:	fseek(fil,(long int)256,SEEK_SET);
       28:  456:	fgets(ret,16,fil);
       28:  457:	while (tmp>0)
        -:  458:	{
    #####:  459:		fgets(ret,16,fil);
    #####:  460:		tmp--;
        -:  461:	}
       28:  462:	fclose(fil);
       28:  463:	return ret;
        -:  464:}
------------------
level_get_name:
       14:  448:char* level_get_name(int lvl,char* ret)
        -:  449:{
        -:  450:	//Translates e.g level 8/256 to "Warrington".
        -:  451:	FILE *fil;
       14:  452:	fil=fopen("location.dat","rb");
       14:  453:	fseek(fil,(long int)lvl,SEEK_SET);
       14:  454:	int tmp=(int)fgetc(fil);
       14:  455:	fseek(fil,(long int)256,SEEK_SET);
       14:  456:	fgets(ret,16,fil);
       14:  457:	while (tmp>0)
        -:  458:	{
    #####:  459:		fgets(ret,16,fil);
    #####:  460:		tmp--;
        -:  461:	}
       14:  462:	fclose(fil);
       14:  463:	return ret;
        -:  464:}
------------------
level_get_name:
       14:  448:char* level_get_name(int lvl,char* ret)
        -:  449:{
        -:  450:	//Translates e.g level 8/256 to "Warrington".
        -:  451:	FILE *fil;
       14:  452:	fil=fopen("location.dat","rb");
       14:  453:	fseek(fil,(long int)lvl,SEEK_SET);
       14:  454:	int tmp=(int)fgetc(fil);
       14:  455:	fseek(fil,(long int)256,SEEK_SET);
       14:  456:	fgets(ret,16,fil);
       14:  457:	while (tmp>0)
        -:  458:	{
    #####:  459:		fgets(ret,16,fil);
    #####:  460:		tmp--;
        -:  461:	}
       14:  462:	fclose(fil);
       14:  463:	return ret;
        -:  464:}
------------------
        -:  465:
        -:  466://distance to player
      736:  467:float distance(float x1, float y1, float x2, float y2)
        -:  468:{
      736:  469:    float dx = x2 - x1;
      736:  470:    float dy = y2 - y1;
      736:  471:    return sqrt(dx * dx + dy * dy);
        -:  472:}
------------------
distance:
      368:  467:float distance(float x1, float y1, float x2, float y2)
        -:  468:{
      368:  469:    float dx = x2 - x1;
      368:  470:    float dy = y2 - y1;
      368:  471:    return sqrt(dx * dx + dy * dy);
        -:  472:}
------------------
distance:
      368:  467:float distance(float x1, float y1, float x2, float y2)
        -:  468:{
      368:  469:    float dx = x2 - x1;
      368:  470:    float dy = y2 - y1;
      368:  471:    return sqrt(dx * dx + dy * dy);
        -:  472:}
------------------
        -:  473:// Function to check for collision between two rectangles; returns true (non-zero) if the rectangles collide, false (0) otherwise
      752:  474:int checkCollision(SDL_Rect rect1, SDL_Rect rect2)
        -:  475:{
     1018:  476:    return (rect1.x < rect2.x + rect2.w &&
      266:  477:            rect1.x + rect1.w > rect2.x &&
      266:  478:            rect1.y < rect2.y + rect2.h &&
     1696:  479:            rect1.y + rect1.h > rect2.y) ||
      700:  480:           (rect2.x < rect1.x + rect1.w &&
      700:  481:            rect2.x + rect2.w > rect1.x &&
      214:  482:            rect2.y < rect1.y + rect1.h &&
       22:  483:            rect2.y + rect2.h > rect1.y);
        -:  484:}
        -:  485:
        -:  486:
        -:  487:
        -:  488:
        -:  489:
        -:  490:
